var jwt = require('jwt-simple'); // JSON web token library
var uuid = require('node-uuid'); // Universally unique identifier (UUID) with timestamp generation
var moment = require('moment');  // Easy handling of date and time - used here for expiry

module.exports = {

	encodeJsonWebToken: function(userID){
		// This function generates and encodes a JSON Web Token (JWT) with userID, expiry, issued, UUID and 
		// some attributes set in config/jwt.js. This data is encoded with a JWT secret set in the config file.
		// This SECRET HAS TO BE CHANGED before this server is put in production.

		// This encoded user- and device-uniqe key is sent in the HTTP header with each request by the client. 
		// This is to avoid sending userID and password in cleartext, and includes device- and server uniqe data.
		// The JWT authentication is dependent on HTTPS to be secure, as a hacker can sniff the HTTP header if
		// it's not encrypted. However, even if an attacker gets ahold of a JWT - it says nothing about which user 
		// it is associated and reveals no data unless it's decoded with the server secret. HTTP over SSL/TLS can
		// easily be configured in config/local.js by changing port and adding a SSL certificate.

		// Expose all the variables in our config/jwt.js file
		var config = sails.config.jwt;

	    // JWT expiry length
	    var expiryLength = config.expiry.length || 1000;
		// JWT expiry format
	    var expiryUnit = config.expiry.unit || 'days';

	    // Sets the expiry of the JWT to 
	    var expires = moment().add(expiryLength, expiryUnit);

	    // Is and should be in seconds for decode library function to work properly
	    var expiresSec = expires.valueOf()/1000;
	    // Human-friendly expiry-format returned to the controller to be input into JWT model created with the user
	    var expiresFormat = expires.format()

	    var issued = Date.now()/1000; // Is and should be in seconds - seconds since 1970 00:00

	    // Format follows jwt-simple library standard which automatically validates the JWT when decoding
		var decodedToken = {
	      iss: userID,
	      sub: config.subject,
	      aud: config.audience,
	      exp: expiresSec,
	      nbf: issued,
	      iat: issued,
	      jti: uuid.v1(),
	    };

	    // DEBUG
	    // sails.log('Decoded token:\n', decodedToken);

	    var token = jwt.encode(decodedToken, config.secret);

	    // DEBUG
	    // sails.log('Token encoded:\n',token);
	    
	    // Returned to UserController.create
	    return {
	      token: token,
	      expires: expiresFormat
	    };
	},

    decodeJsonWebToken: function(token){
  		// Decodes token using jwt-simple library. The library validates when decoding which, if not valid,
  		// triggers an error handled here. The error message is sent back to the policy and user is denied access.
  		// It checks if 1) token exists, 2) token-string is on correct format (needs three 'segments' split by '.')
  		// 3) encoding-algorithm is supported, 4) signature verification (ie. generated by server)
  		// 5) expiry past and 6) token not yet active (issued date in the future)

  		try{
  			var decodedToken = jwt.decode(token, sails.config.jwt.secret);
  		} catch (err) {
  			// If the accessToken-string passes the formating-test of the decoder (3 segments split with '.' )
  			// but makes no sense otherwise - the JWT does not exist. This handles error-outputs form decoder
  			if (err.message === 'Unexpected token j' || err.message ===  'Unexpected end of input') 
  				return {errorMessage: "Specified JSON web token does not exist", errorCaught: true};
    		// Failed validation, errorCaught flag set and error message returned
    		return {errorMessage: err.message, errorCaught: true}
  		} // All is well, decoded token-object along with errorCaught flag
  		return {token: decodedToken, errorCaught: false};
	},

	hasFullAccess: function(accessToken) {
		// Checks if input-token is part of the list of admin-tokens
		var allowedTokens = sails.config.jwt.adminTokens;

		// If access token is not defined in HTTP header
		if (typeof accessToken === 'undefined') return false;
		
		for (var i = 0; i < allowedTokens.length; i++){
			if (allowedTokens[i] === accessToken){
				return true;
			}
		} return false;
	}
};